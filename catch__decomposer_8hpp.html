<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Software Ontwikkeling: app/Catch2/src/catch2/internal/catch_decomposer.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="placeholder.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Software Ontwikkeling
   &#160;<span id="projectnumber">0</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d422163b96683743ed3963d4aac17747.html">app</a></li><li class="navelem"><a class="el" href="dir_d78b865ef2947f56103157fffda31130.html">Catch2</a></li><li class="navelem"><a class="el" href="dir_65067afbb9b4e66b45336a6e08147f46.html">src</a></li><li class="navelem"><a class="el" href="dir_1fac34cabb46fc40bed2a1bc152ff014.html">catch2</a></li><li class="navelem"><a class="el" href="dir_307a3edc162bd154c05c1b4bb9d187d1.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">catch_decomposer.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="catch__tostring_8hpp_source.html">catch2/catch_tostring.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="catch__stringref_8hpp_source.html">catch2/internal/catch_stringref.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="catch__compare__traits_8hpp_source.html">catch2/internal/catch_compare_traits.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="catch__test__failure__exception_8hpp_source.html">catch2/internal/catch_test_failure_exception.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="catch__logical__traits_8hpp_source.html">catch2/internal/catch_logical_traits.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="catch__compiler__capabilities_8hpp_source.html">catch2/internal/catch_compiler_capabilities.hpp</a>&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;iosfwd&gt;</code><br />
</div>
<p><a href="catch__decomposer_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1capture__by__value.html">Catch::capture_by_value&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1always__false.html">Catch::always_false&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCatch_1_1ITransientExpression.html">Catch::ITransientExpression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCatch_1_1BinaryExpr.html">Catch::BinaryExpr&lt; LhsT, RhsT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCatch_1_1UnaryExpr.html">Catch::UnaryExpr&lt; LhsT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCatch_1_1ExprLhs.html">Catch::ExprLhs&lt; LhsT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1Decomposer.html">Catch::Decomposer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCatch"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCatch.html">Catch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCatch_1_1Detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCatch_1_1Detail.html">Catch::Detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aea22592bf22edde6e70861c9b3b2bf51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__decomposer_8hpp.html#aea22592bf22edde6e70861c9b3b2bf51">CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR</a>(id,  op)</td></tr>
<tr class="separator:aea22592bf22edde6e70861c9b3b2bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174ed3879abb714748caf24811434362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__decomposer_8hpp.html#a174ed3879abb714748caf24811434362">CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR</a>(id,  op)</td></tr>
<tr class="separator:a174ed3879abb714748caf24811434362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabca54677fdc77aa49edd62439e706b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__decomposer_8hpp.html#aabca54677fdc77aa49edd62439e706b3">CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR</a>(op)</td></tr>
<tr class="separator:aabca54677fdc77aa49edd62439e706b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a520110c31f26cf9892595772ab814fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCatch.html#a520110c31f26cf9892595772ab814fc0">Catch::formatReconstructedExpression</a> (std::ostream &amp;os, std::string const &amp;lhs, StringRef op, std::string const &amp;rhs)</td></tr>
<tr class="separator:a520110c31f26cf9892595772ab814fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Why does decomposing look the way it does:</p>
<p>Conceptually, decomposing is simple. We change <code>REQUIRE( a == b )</code> into <code>Decomposer{} &lt;= a == b</code>, so that <code>Decomposer{} &lt;= a</code> is evaluated first, and our custom operator is used for <code>a == b</code>, because <code>a</code> is transformed into <code>ExprLhs&lt;T&amp;&gt;</code> and then into <code>BinaryExpr&lt;T&amp;, U&amp;&gt;</code>.</p>
<p>In practice, decomposing ends up a mess, because we have to support various fun things.</p>
<p>1) Types that are only comparable with literal 0, and they do this by comparing against a magic type with pointer constructor and deleted other constructors. Example: <code>REQUIRE((a &lt;=&gt; b) == 0)</code> in libstdc++</p>
<p>2) Types that are only comparable with literal 0, and they do this by comparing against a magic type with consteval integer constructor. Example: <code>REQUIRE((a &lt;=&gt; b) == 0)</code> in current MSVC STL.</p>
<p>3) Types that have no linkage, and so we cannot form a reference to them. Example: some implementations of traits.</p>
<p>4) Starting with C++20, when the compiler sees <code>a == b</code>, it also uses <code>b == a</code> when constructing the overload set. For us this means that when the compiler handles <code>ExprLhs&lt;T&gt; == b</code>, it also tries to resolve the overload set for <code>b == ExprLhs&lt;T&gt;</code>.</p>
<p>To accomodate these use cases, decomposer ended up rather complex.</p>
<p>1) These types are handled by adding SFINAE overloads to our comparison operators, checking whether <code>T == U</code> are comparable with the given operator, and if not, whether T (or U) are comparable with literal 0. If yes, the overload compares T (or U) with 0 literal inline in the definition.</p>
<p>Note that for extra correctness, we check that the other type is either an <code>int</code> (literal 0 is captured as <code>int</code> by templates), or a <code>long</code> (some platforms use 0L for <code>NULL</code> and we want to support that for pointer comparisons).</p>
<p>2) For these types, <code>is_foo_comparable&lt;T, int&gt;</code> is true, but letting them fall into the overload that actually does <code>T == int</code> causes compilation error. Handling them requires that the decomposition is <code>constexpr</code>, so that P2564R3 applies and the <code>consteval</code> from their accompanying magic type is propagated through the <code>constexpr</code> call stack.</p>
<p>However this is not enough to handle these types automatically, because our default is to capture types by reference, to avoid runtime copies. While these references cannot become dangling, they outlive the constexpr context and thus the default capture path cannot be actually constexpr.</p>
<p>The solution is to capture these types by value, by explicitly specializing <code><a class="el" href="structCatch_1_1capture__by__value.html">Catch::capture_by_value</a></code> for them. Catch2 provides specialization for <code>std::foo_ordering</code>s, but users can specialize the trait for their own types as well.</p>
<p>3) If a type has no linkage, we also cannot capture it by reference. The solution is once again to capture them by value. We handle the common cases by using <code>std::is_arithmetic</code> as the default for <code><a class="el" href="structCatch_1_1capture__by__value.html">Catch::capture_by_value</a></code>, but that is only a some-effort heuristic. But as with 2), users can specialize <code>capture_by_value</code> for their own types as needed.</p>
<p>4) To support C++20 and make the SFINAE on our decomposing operators work, the SFINAE has to happen in return type, rather than in a template type. This is due to our use of logical type traits (<code>conjunction</code>/<code>disjunction</code>/<code>negation</code>), that we use to workaround an issue in older (9-) versions of GCC. I still blame C++20 for this, because without the comparison order switching, the logical traits could still be used in template type.</p>
<p>There are also other side concerns, e.g. supporting both <code><a class="el" href="catch__test__macros_8hpp.html#ad57835ba8f1bb419a865ada6bd011a85">REQUIRE(a)</a></code> and <code>REQUIRE(a == b)</code>, or making <code><a class="el" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT(a, IsEqual(b))</a></code> slot nicely into the same expression handling logic, but these are rather straightforward and add only a bit of complexity (e.g. common base class for decomposed expressions). </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a174ed3879abb714748caf24811434362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174ed3879abb714748caf24811434362">&#9670;&nbsp;</a></span>CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea22592bf22edde6e70861c9b3b2bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea22592bf22edde6e70861c9b3b2bf51">&#9670;&nbsp;</a></span>CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabca54677fdc77aa49edd62439e706b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabca54677fdc77aa49edd62439e706b3">&#9670;&nbsp;</a></span>CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RhsT&gt;                                                   \</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keyword">auto</span> <span class="keyword">operator</span> op( ExprLhs&amp;&amp; lhs, RhsT&amp;&amp; rhs )             \</div>
<div class="line">        -&gt; std::enable_if_t&lt;                                                   \</div>
<div class="line">            !capture_by_value&lt;Detail::RemoveCVRef_t&lt;RhsT&gt;&gt;<a class="code" href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">::value</a>,             \</div>
<div class="line">            BinaryExpr&lt;LhsT, RhsT const&amp;&gt;&gt; {                                   \</div>
<div class="line">        return {                                                               \</div>
<div class="line">            static_cast&lt;bool&gt;( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \</div>
<div class="line">    }                                                                          \</div>
<div class="line">    template &lt;typename RhsT&gt;                                                   \</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keyword">auto</span> <span class="keyword">operator</span> op( ExprLhs&amp;&amp; lhs, RhsT rhs )               \</div>
<div class="line">        -&gt; <a class="code" href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">std::enable_if_t&lt;capture_by_value&lt;RhsT&gt;::value</a>,                     \</div>
<div class="line">                            BinaryExpr&lt;LhsT, RhsT&gt;&gt; {                          \</div>
<div class="line">        return {                                                               \</div>
<div class="line">            static_cast&lt;bool&gt;( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \</div>
<div class="line">    }</div>
<div class="ttc" id="acatch__amalgamated_8cpp_html_a5dcc1560b74135e065519bc3986c14b1"><div class="ttname"><a href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">value</a></div><div class="ttdeci">StringRef value</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:5196</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
