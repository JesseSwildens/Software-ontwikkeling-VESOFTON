<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Software Ontwikkeling: matchers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="placeholder.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Software Ontwikkeling
   &#160;<span id="projectnumber">0</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">matchers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="top"></a> </p>
<h1><a class="anchor" id="autotoc_md205"></a>
Matchers</h1>
<p><b>Contents</b><br  />
 <a href="#using-matchers">Using Matchers</a><br  />
 <a href="#built-in-matchers">Built-in matchers</a><br  />
 <a href="#writing-custom-matchers-old-style">Writing custom matchers (old style)</a><br  />
 <a href="#writing-custom-matchers-new-style">Writing custom matchers (new style)</a><br  />
</p>
<p>Matchers, as popularized by the <a href="https://en.wikipedia.org/wiki/Hamcrest">Hamcrest</a> framework are an alternative way to write assertions, useful for tests where you work with complex types or need to assert more complex properties. Matchers are easily composable and users can write their own and combine them with the Catch2-provided matchers seamlessly.</p>
<h2><a class="anchor" id="autotoc_md206"></a>
Using Matchers</h2>
<p>Matchers are most commonly used in tandem with the <code>REQUIRE_THAT</code> or <code>CHECK_THAT</code> macros. The <code>REQUIRE_THAT</code> macro takes two arguments, the first one is the input (object/value) to test, the second argument is the matcher itself.</p>
<p>For example, to assert that a string ends with the "as a service" substring, you can write the following assertion</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceCatch_1_1Matchers.html#aee26f4e3f2ca725a42d7b1db56654fa4">Catch::Matchers::EndsWith</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a>( getSomeString(), <a class="code" href="namespaceCatch_1_1Matchers.html#aee26f4e3f2ca725a42d7b1db56654fa4">EndsWith</a>(<span class="stringliteral">&quot;as a service&quot;</span>) );</div>
<div class="ttc" id="acatch__matchers_8hpp_html_ac1354db6f3e9c1e0a8eda0eea7ff1f0a"><div class="ttname"><a href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a></div><div class="ttdeci">#define REQUIRE_THAT(arg, matcher)</div><div class="ttdef"><b>Definition:</b> catch_matchers.hpp:222</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_aee26f4e3f2ca725a42d7b1db56654fa4"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#aee26f4e3f2ca725a42d7b1db56654fa4">Catch::Matchers::EndsWith</a></div><div class="ttdeci">EndsWithMatcher EndsWith(std::string const &amp;str, CaseSensitive caseSensitivity)</div><div class="ttdoc">Creates matcher that accepts strings that end with str</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8367</div></div>
</div><!-- fragment --><p>Individual matchers can also be combined using the C++ logical operators, that is <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>, like so:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceCatch_1_1Matchers.html#aee26f4e3f2ca725a42d7b1db56654fa4">Catch::Matchers::EndsWith</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespaceCatch_1_1Matchers.html#a4d2b025a4c734b1f22ea3db83e9d6c92">Catch::Matchers::ContainsSubstring</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a>( getSomeString(),</div>
<div class="line">              <a class="code" href="namespaceCatch_1_1Matchers.html#aee26f4e3f2ca725a42d7b1db56654fa4">EndsWith</a>(<span class="stringliteral">&quot;as a service&quot;</span>) &amp;&amp; <a class="code" href="namespaceCatch_1_1Matchers.html#a4d2b025a4c734b1f22ea3db83e9d6c92">ContainsSubstring</a>(<span class="stringliteral">&quot;web scale&quot;</span>));</div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_a4d2b025a4c734b1f22ea3db83e9d6c92"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#a4d2b025a4c734b1f22ea3db83e9d6c92">Catch::Matchers::ContainsSubstring</a></div><div class="ttdeci">StringContainsMatcher ContainsSubstring(std::string const &amp;str, CaseSensitive caseSensitivity)</div><div class="ttdoc">Creates matcher that accepts strings that contain str</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8364</div></div>
</div><!-- fragment --><p>The example above asserts that the string returned from <code>getSomeString</code> <em>both</em> ends with the suffix "as a service" <em>and</em> contains the string "web scale" somewhere.</p>
<p>Both of the string matchers used in the examples above live in the <code><a class="el" href="catch__matchers__string_8hpp.html">catch_matchers_string.hpp</a></code> header, so to compile the code above also requires <code>#include &lt;<a class="el" href="catch__matchers__string_8hpp.html">catch2/matchers/catch_matchers_string.hpp</a>&gt;</code>.</p>
<h3><a class="anchor" id="autotoc_md207"></a>
Combining operators and lifetimes</h3>
<p><b>IMPORTANT</b>: The combining operators do not take ownership of the matcher objects being combined.</p>
<p>This means that if you store combined matcher object, you have to ensure that the individual matchers being combined outlive the combined matcher. Note that the negation matcher from <code>!</code> also counts as combining matcher for this.</p>
<p>Explained on an example, this is fine </p><div class="fragment"><div class="line"><a class="code" href="catch__matchers_8hpp.html#a5b8c33c63e0804d4458e2c761370b75d">CHECK_THAT</a>(<a class="code" href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">value</a>, <a class="code" href="namespaceCatch_1_1Matchers.html#a13a915665906ab3efb39e118c649285f">WithinAbs</a>(0, 2e-2) &amp;&amp; !<a class="code" href="namespaceCatch_1_1Matchers.html#a88361ad809aab09ff75c87bf6cdd7fad">WithinULP</a>(0., 1));</div>
<div class="ttc" id="acatch__amalgamated_8cpp_html_a5dcc1560b74135e065519bc3986c14b1"><div class="ttname"><a href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">value</a></div><div class="ttdeci">StringRef value</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:5196</div></div>
<div class="ttc" id="acatch__matchers_8hpp_html_a5b8c33c63e0804d4458e2c761370b75d"><div class="ttname"><a href="catch__matchers_8hpp.html#a5b8c33c63e0804d4458e2c761370b75d">CHECK_THAT</a></div><div class="ttdeci">#define CHECK_THAT(arg, matcher)</div><div class="ttdef"><b>Definition:</b> catch_matchers.hpp:221</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_a13a915665906ab3efb39e118c649285f"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#a13a915665906ab3efb39e118c649285f">Catch::Matchers::WithinAbs</a></div><div class="ttdeci">WithinAbsMatcher WithinAbs(double target, double margin)</div><div class="ttdoc">Creates a matcher that accepts numbers within certain range of target.</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8211</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_a88361ad809aab09ff75c87bf6cdd7fad"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#a88361ad809aab09ff75c87bf6cdd7fad">Catch::Matchers::WithinULP</a></div><div class="ttdeci">WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff)</div><div class="ttdoc">Creates a matcher that accepts doubles within certain ULP range of target.</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8203</div></div>
</div><!-- fragment --><p>and so is this </p><div class="fragment"><div class="line"><span class="keyword">auto</span> is_close_to_zero = <a class="code" href="namespaceCatch_1_1Matchers.html#a13a915665906ab3efb39e118c649285f">WithinAbs</a>(0, 2e-2);</div>
<div class="line"><span class="keyword">auto</span> is_zero          = <a class="code" href="namespaceCatch_1_1Matchers.html#a88361ad809aab09ff75c87bf6cdd7fad">WithinULP</a>(0., 1);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#a5b8c33c63e0804d4458e2c761370b75d">CHECK_THAT</a>(<a class="code" href="catch__amalgamated_8cpp.html#a5dcc1560b74135e065519bc3986c14b1">value</a>, is_close_to_zero &amp;&amp; !is_zero);</div>
</div><!-- fragment --><p>but this is not </p><div class="fragment"><div class="line"><span class="keyword">auto</span> is_close_to_zero = <a class="code" href="namespaceCatch_1_1Matchers.html#a13a915665906ab3efb39e118c649285f">WithinAbs</a>(0, 2e-2);</div>
<div class="line"><span class="keyword">auto</span> is_zero          = <a class="code" href="namespaceCatch_1_1Matchers.html#a88361ad809aab09ff75c87bf6cdd7fad">WithinULP</a>(0., 1);</div>
<div class="line"><span class="keyword">auto</span> is_close_to_but_not_zero = is_close_to_zero &amp;&amp; !is_zero;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#a5b8c33c63e0804d4458e2c761370b75d">CHECK_THAT</a>(a_value, is_close_to_but_not_zero); <span class="comment">// UAF</span></div>
</div><!-- fragment --><p>because <code>!is_zero</code> creates a temporary instance of Negation matcher, which the <code>is_close_to_but_not_zero</code> refers to. After the line ends, the temporary is destroyed and the combined <code>is_close_to_but_not_zero</code> matcher now refers to non-existent object, so using it causes use-after-free.</p>
<h2><a class="anchor" id="autotoc_md208"></a>
Built-in matchers</h2>
<p>Every matcher provided by Catch2 is split into 2 parts, a factory function that lives in the <code><a class="el" href="namespaceCatch_1_1Matchers.html">Catch::Matchers</a></code> namespace, and the actual matcher type that is in some deeper namespace and should not be used by the user. In the examples above, we used <code><a class="el" href="namespaceCatch_1_1Matchers.html#a3daedac3f40eac073e62c4accc4324b7">Catch::Matchers::Contains</a></code>. This is the factory function for the <code>Catch::Matchers::StdString::ContainsMatcher</code> type that does the actual matching.</p>
<p>Out of the box, Catch2 provides the following matchers:</p>
<h3><a class="anchor" id="autotoc_md209"></a>
&lt;tt&gt;std::string&lt;/tt&gt; matchers</h3>
<p>Catch2 provides 5 different matchers that work with <code>std::string</code>,</p><ul>
<li><code>StartsWith(std::string str, CaseSensitive)</code>,</li>
<li><code>EndsWith(std::string str, CaseSensitive)</code>,</li>
<li><code>ContainsSubstring(std::string str, CaseSensitive)</code>,</li>
<li><code>Equals(std::string str, CaseSensitive)</code>, and</li>
<li><code>Matches(std::string str, CaseSensitive)</code>.</li>
</ul>
<p>The first three should be fairly self-explanatory, they succeed if the argument starts with <code>str</code>, ends with <code>str</code>, or contains <code>str</code> somewhere inside it.</p>
<p>The <code>Equals</code> matcher matches a string if (and only if) the argument string is equal to <code>str</code>.</p>
<p>Finally, the <code>Matches</code> matcher performs an ECMAScript regex match using <code>str</code> against the argument string. It is important to know that the match is performed against the string as a whole, meaning that the regex <code>"abc"</code> will not match input string <code>"abcd"</code>. To match <code>"abcd"</code>, you need to use e.g. <code>"abc.*"</code> as your regex.</p>
<p>The second argument sets whether the matching should be case-sensitive or not. By default, it is case-sensitive.</p>
<blockquote class="doxtable">
<p><code>std::string</code> matchers live in <code><a class="el" href="catch__matchers__string_8hpp.html">catch2/matchers/catch_matchers_string.hpp</a></code> </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md210"></a>
Vector matchers</h3>
<p><em>Vector matchers have been deprecated in favour of the generic range matchers with the same functionality.</em></p>
<p>Catch2 provides 5 built-in matchers that work on <code>std::vector</code>.</p>
<p>These are</p>
<ul>
<li><code>Contains</code> which checks whether a specified vector is present in the result</li>
<li><code>VectorContains</code> which checks whether a specified element is present in the result</li>
<li><code>Equals</code> which checks whether the result is exactly equal (order matters) to a specific vector</li>
<li><code>UnorderedEquals</code> which checks whether the result is equal to a specific vector under a permutation</li>
<li><code>Approx</code> which checks whether the result is "approx-equal" (order matters, but comparison is done via <code>Approx</code>) to a specific vector <blockquote class="doxtable">
<p>Approx matcher was <a href="https://github.com/catchorg/Catch2/issues/1499">introduced</a> in Catch2 2.7.2. </p>
</blockquote>
An example usage: <div class="fragment"><div class="line">std::vector&lt;int&gt; some_vec{ 1, 2, 3 };</div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a>(some_vec, <a class="code" href="namespaceCatch_1_1Matchers.html#a7467c33640c6845ce68233fa7cffb7b9">Catch::Matchers::UnorderedEquals</a>(std::vector&lt;int&gt;{ 3, 2, 1 }));</div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_a7467c33640c6845ce68233fa7cffb7b9"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#a7467c33640c6845ce68233fa7cffb7b9">Catch::Matchers::UnorderedEquals</a></div><div class="ttdeci">UnorderedEqualsMatcher&lt; T, AllocComp, AllocMatch &gt; UnorderedEquals(std::vector&lt; T, AllocComp &gt; const &amp;target)</div><div class="ttdoc">Creates a matcher that matches vectors that is equal to target modulo permutation.</div><div class="ttdef"><b>Definition:</b> catch_matchers_vector.hpp:187</div></div>
</div><!-- fragment --></li>
</ul>
<p>This assertions will pass, because the elements given to the matchers are a permutation of the ones in <code>some_vec</code>.</p>
<blockquote class="doxtable">
<p>vector matchers live in <code><a class="el" href="catch__matchers__vector_8hpp.html">catch2/matchers/catch_matchers_vector.hpp</a></code> </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md211"></a>
Floating point matchers</h3>
<p>Catch2 provides 4 matchers that target floating point numbers. These are:</p>
<ul>
<li><code>WithinAbs(double target, double margin)</code>,</li>
<li><code>WithinULP(FloatingPoint target, uint64_t maxUlpDiff)</code>, and</li>
<li><code>WithinRel(FloatingPoint target, FloatingPoint eps)</code>.</li>
<li><code><a class="el" href="namespaceCatch_1_1Matchers.html#a0d170fa146d9a4ec0d908acce010128e">IsNaN()</a></code></li>
</ul>
<blockquote class="doxtable">
<p><code>WithinRel</code> matcher was introduced in Catch2 2.10.0 </p>
</blockquote>
<blockquote class="doxtable">
<p><code>IsNaN</code> matcher was introduced in Catch2 3.3.2. </p>
</blockquote>
<p>The first three serve to compare two floating pointe numbers. For more details about how they work, read <a href="comparing-floating-point-numbers.md#floating-point-matchers">the docs on comparing floating point numbers</a>.</p>
<p><code>IsNaN</code> then does exactly what it says on the tin. It matches the input if it is a NaN (Not a Number). The advantage of using it over just plain <code><a class="el" href="catch__test__macros_8hpp.html#ad57835ba8f1bb419a865ada6bd011a85">REQUIRE(std::isnan(x))</a></code>, is that if the check fails, with <code>REQUIRE</code> you won't see the value of <code>x</code>, but with <code><a class="el" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT(x, IsNaN())</a></code>, you will.</p>
<h3><a class="anchor" id="autotoc_md212"></a>
Miscellaneous matchers</h3>
<p>Catch2 also provides some matchers and matcher utilities that do not quite fit into other categories.</p>
<p>The first one of them is the <code>Predicate(Callable pred, std::string description)</code> matcher. It creates a matcher object that calls <code>pred</code> for the provided argument. The <code>description</code> argument allows users to set what the resulting matcher should self-describe as if required.</p>
<p>Do note that you will need to explicitly specify the type of the argument, like in this example:</p>
<div class="fragment"><div class="line"><a class="code" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a>(<span class="stringliteral">&quot;Hello olleH&quot;</span>,</div>
<div class="line">             Predicate&lt;std::string&gt;(</div>
<div class="line">                 [] (std::string <span class="keyword">const</span>&amp; str) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> str.front() == str.back(); },</div>
<div class="line">                 <span class="stringliteral">&quot;First and last character should be equal&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>the predicate matcher lives in <code><a class="el" href="catch__matchers__predicate_8hpp.html">catch2/matchers/catch_matchers_predicate.hpp</a></code> </p>
</blockquote>
<p>The other miscellaneous matcher utility is exception matching.</p>
<h4><a class="anchor" id="autotoc_md213"></a>
Matching exceptions</h4>
<p>Catch2 provides a utility macro for asserting that an expression throws exception of specific type, and that the exception has desired properties. The macro is <code><a class="el" href="catch__matchers_8hpp.html#a54473a48ac2ac55bfe1165b69e1b8010">REQUIRE_THROWS_MATCHES(expr, ExceptionType, Matcher)</a></code>.</p>
<blockquote class="doxtable">
<p><code>REQUIRE_THROWS_MATCHES</code> macro lives in <code><a class="el" href="catch__matchers_8hpp.html">catch2/matchers/catch_matchers.hpp</a></code> </p>
</blockquote>
<p>Catch2 currently provides two matchers for exceptions. These are:</p><ul>
<li><code>Message(std::string message)</code>.</li>
<li><code>MessageMatches(Matcher matcher)</code>.</li>
</ul>
<blockquote class="doxtable">
<p><code>MessageMatches</code> was <a href="https://github.com/catchorg/Catch2/pull/2570">introduced</a> in Catch2 3.3.0 </p>
</blockquote>
<p><code>Message</code> checks that the exception's message, as returned from <code>what</code> is exactly equal to <code>message</code>.</p>
<p><code>MessageMatches</code> applies the provided matcher on the exception's message, as returned from <code>what</code>. This is useful in conjunctions with the <code>std::string</code> matchers (e.g. <code>StartsWith</code>)</p>
<p>Example use: </p><div class="fragment"><div class="line"><a class="code" href="catch__matchers_8hpp.html#a54473a48ac2ac55bfe1165b69e1b8010">REQUIRE_THROWS_MATCHES</a>(throwsDerivedException(),  DerivedException,  <a class="code" href="namespaceCatch_1_1Matchers.html#af11fe22b71a449fc411d47ea91cabd13">Message</a>(<span class="stringliteral">&quot;DerivedException::what&quot;</span>));</div>
<div class="line"><a class="code" href="catch__matchers_8hpp.html#a54473a48ac2ac55bfe1165b69e1b8010">REQUIRE_THROWS_MATCHES</a>(throwsDerivedException(),  DerivedException,  <a class="code" href="namespaceCatch_1_1Matchers.html#abab96349df5c5b4722ea5307cc7e4e0d">MessageMatches</a>(<a class="code" href="namespaceCatch_1_1Matchers.html#aa830bf8902f231a7df15c13f81d0e268">StartsWith</a>(<span class="stringliteral">&quot;DerivedException&quot;</span>)));</div>
<div class="ttc" id="acatch__matchers_8hpp_html_a54473a48ac2ac55bfe1165b69e1b8010"><div class="ttname"><a href="catch__matchers_8hpp.html#a54473a48ac2ac55bfe1165b69e1b8010">REQUIRE_THROWS_MATCHES</a></div><div class="ttdeci">#define REQUIRE_THROWS_MATCHES(expr, exceptionType, matcher)</div><div class="ttdef"><b>Definition:</b> catch_matchers.hpp:216</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_aa830bf8902f231a7df15c13f81d0e268"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#aa830bf8902f231a7df15c13f81d0e268">Catch::Matchers::StartsWith</a></div><div class="ttdeci">StartsWithMatcher StartsWith(std::string const &amp;str, CaseSensitive caseSensitivity)</div><div class="ttdoc">Creates matcher that accepts strings that start with str</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8370</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_abab96349df5c5b4722ea5307cc7e4e0d"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#abab96349df5c5b4722ea5307cc7e4e0d">Catch::Matchers::MessageMatches</a></div><div class="ttdeci">ExceptionMessageMatchesMatcher&lt; StringMatcherType &gt; MessageMatches(StringMatcherType &amp;&amp;matcher)</div><div class="ttdef"><b>Definition:</b> catch_matchers_exception.hpp:54</div></div>
<div class="ttc" id="anamespaceCatch_1_1Matchers_html_af11fe22b71a449fc411d47ea91cabd13"><div class="ttname"><a href="namespaceCatch_1_1Matchers.html#af11fe22b71a449fc411d47ea91cabd13">Catch::Matchers::Message</a></div><div class="ttdeci">ExceptionMessageMatcher Message(std::string const &amp;message)</div><div class="ttdoc">Creates a matcher that checks whether a std derived exception has the provided message.</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.cpp:8025</div></div>
</div><!-- fragment --><p>Note that <code>DerivedException</code> in the example above has to derive from <code>std::exception</code> for the example to work.</p>
<blockquote class="doxtable">
<p>the exception message matcher lives in <code><a class="el" href="catch__matchers__exception_8hpp.html">catch2/matchers/catch_matchers_exception.hpp</a></code> </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md214"></a>
Generic range Matchers</h3>
<blockquote class="doxtable">
<p>Generic range matchers were introduced in Catch2 3.0.1 </p>
</blockquote>
<p>Catch2 also provides some matchers that use the new style matchers definitions to handle generic range-like types. These are:</p>
<ul>
<li><code><a class="el" href="namespaceCatch_1_1Matchers.html#ae345560f84f68d52fc5df4ac77eb4b92" title="Creates a matcher that accepts empty ranges/containers.">IsEmpty()</a></code></li>
<li><code>SizeIs(size_t target_size)</code></li>
<li><code>SizeIs(Matcher size_matcher)</code></li>
<li><code>Contains(T&amp;&amp; target_element, Comparator = std::equal_to&lt;&gt;{})</code></li>
<li><code>Contains(Matcher element_matcher)</code></li>
<li><code>AllMatch(Matcher element_matcher)</code></li>
<li><code>AnyMatch(Matcher element_matcher)</code></li>
<li><code>NoneMatch(Matcher element_matcher)</code></li>
<li><code><a class="el" href="namespaceCatch_1_1Matchers.html#a4f719bca42718f4936668308772732ae">AllTrue()</a></code>, <code><a class="el" href="namespaceCatch_1_1Matchers.html#a99b3d0b547a4335b786e8fcea6a11cad">AnyTrue()</a></code>, <code><a class="el" href="namespaceCatch_1_1Matchers.html#a072ee44afcb1647b55b6c3437f22af44">NoneTrue()</a></code></li>
<li><code>RangeEquals(TargetRangeLike&amp;&amp;, Comparator = std::equal_to&lt;&gt;{})</code></li>
<li><code>UnorderedRangeEquals(TargetRangeLike&amp;&amp;, Comparator = std::equal_to&lt;&gt;{})</code></li>
</ul>
<blockquote class="doxtable">
<p><code>IsEmpty</code>, <code>SizeIs</code>, <code>Contains</code> were introduced in Catch2 3.0.1 </p>
</blockquote>
<blockquote class="doxtable">
<p><code>All/Any/NoneMatch</code> were introduced in Catch2 3.0.1 </p>
</blockquote>
<blockquote class="doxtable">
<p><code>All/Any/NoneTrue</code> were introduced in Catch2 3.1.0 </p>
</blockquote>
<blockquote class="doxtable">
<p><code>RangeEquals</code> and <code>UnorderedRangeEquals</code> matchers were <a href="https://github.com/catchorg/Catch2/pull/2377">introduced</a> in Catch2 3.3.0 </p>
</blockquote>
<p><code>IsEmpty</code> should be self-explanatory. It successfully matches objects that are empty according to either <code>std::empty</code>, or ADL-found <code>empty</code> free function.</p>
<p><code>SizeIs</code> checks range's size. If constructed with <code>size_t</code> arg, the matchers accepts ranges whose size is exactly equal to the arg. If constructed from another matcher, then the resulting matcher accepts ranges whose size is accepted by the provided matcher.</p>
<p><code>Contains</code> accepts ranges that contain specific element. There are again two variants, one that accepts the desired element directly, in which case a range is accepted if any of its elements is equal to the target element. The other variant is constructed from a matcher, in which case a range is accepted if any of its elements is accepted by the provided matcher.</p>
<p><code>AllMatch</code>, <code>NoneMatch</code>, and <code>AnyMatch</code> match ranges for which either all, none, or any of the contained elements matches the given matcher, respectively.</p>
<p><code>AllTrue</code>, <code>NoneTrue</code>, and <code>AnyTrue</code> match ranges for which either all, none, or any of the contained elements are <code>true</code>, respectively. It works for ranges of <code>bool</code>s and ranges of elements (explicitly) convertible to <code>bool</code>.</p>
<p><code>RangeEquals</code> compares the range that the matcher is constructed with (the "target range") against the range to be tested, element-wise. The match succeeds if all elements from the two ranges compare equal (using <code>operator==</code> by default). The ranges do not need to be the same type, and the element types do not need to be the same, as long as they are comparable. (e.g. you may compare <code>std::vector&lt;int&gt;</code> to <code>std::array&lt;char&gt;</code>).</p>
<p><code>UnorderedRangeEquals</code> is similar to <code>RangeEquals</code>, but the order does not matter. For example "1, 2, 3" would match "3, 2, 1", but not "1, 1, 2, 3" As with <code>RangeEquals</code>, <code>UnorderedRangeEquals</code> compares the individual elements using <code>operator==</code> by default.</p>
<p>Both <code>RangeEquals</code> and <code>UnorderedRangeEquals</code> optionally accept a predicate which can be used to compare the containers element-wise.</p>
<p>To check a container elementwise against a given matcher, use <code>AllMatch</code>.</p>
<h2><a class="anchor" id="autotoc_md215"></a>
Writing custom matchers (old style)</h2>
<p>The old style of writing matchers has been introduced back in <a class="el" href="namespaceCatch.html">Catch</a> Classic. To create an old-style matcher, you have to create your own type that derives from <code><a class="el" href="classCatch_1_1Matchers_1_1MatcherBase.html">Catch::Matchers::MatcherBase</a>&lt;ArgT&gt;</code>, where <code>ArgT</code> is the type your matcher works for. Your type has to override two methods, <code>bool match(ArgT const&amp;) const</code>, and <code>std::string describe() const</code>.</p>
<p>As the name suggests, <code>match</code> decides whether the provided argument is matched (accepted) by the matcher. <code>describe</code> then provides a human-oriented description of what the matcher does.</p>
<p>We also recommend that you create factory function, just like Catch2 does, but that is mostly useful for template argument deduction for templated matchers (assuming you do not have CTAD available).</p>
<p>To combine these into an example, let's say that you want to write a matcher that decides whether the provided argument is a number within certain range. We will call it <code>IsBetweenMatcher&lt;T&gt;</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;catch2/catch_test_macros.hpp&gt;</div>
<div class="line">#include &lt;catch2/matchers/catch_matchers.hpp&gt;</div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class IsBetweenMatcher : public Catch::Matchers::MatcherBase&lt;T&gt; {</div>
<div class="line">    T m_begin, m_end;</div>
<div class="line">public:</div>
<div class="line">    IsBetweenMatcher(T begin, T end) : m_begin(begin), m_end(end) {}</div>
<div class="line"> </div>
<div class="line">    bool match(T const&amp; in) const override {</div>
<div class="line">        return in &gt;= m_begin &amp;&amp; in &lt;= m_end;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string describe() const override {</div>
<div class="line">        std::ostringstream ss;</div>
<div class="line">        ss &lt;&lt; &quot;is between &quot; &lt;&lt; m_begin &lt;&lt; &quot; and &quot; &lt;&lt; m_end;</div>
<div class="line">        return ss.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">IsBetweenMatcher&lt;T&gt; IsBetween(T begin, T end) {</div>
<div class="line">    return { begin, end };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">TEST_CASE(&quot;Numbers are within range&quot;) {</div>
<div class="line">    // infers `double` for the argument type of the matcher</div>
<div class="line">    CHECK_THAT(3., IsBetween(1., 10.));</div>
<div class="line">    // infers `int` for the argument type of the matcher</div>
<div class="line">    CHECK_THAT(100, IsBetween(1, 10));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Obviously, the code above can be improved somewhat, for example you might want to <code>static_assert</code> over the fact that <code>T</code> is an arithmetic type... or generalize the matcher to cover any type for which the user can provide a comparison function object.</p>
<p>Note that while any matcher written using the old style can also be written using the new style, combining old style matchers should generally compile faster. Also note that you can combine old and new style matchers arbitrarily.</p>
<blockquote class="doxtable">
<p><code>MatcherBase</code> lives in <code><a class="el" href="catch__matchers_8hpp.html">catch2/matchers/catch_matchers.hpp</a></code> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md216"></a>
Writing custom matchers (new style)</h2>
<blockquote class="doxtable">
<p>New style matchers were introduced in Catch2 3.0.1 </p>
</blockquote>
<p>To create a new-style matcher, you have to create your own type that derives from <code><a class="el" href="classCatch_1_1Matchers_1_1MatcherGenericBase.html">Catch::Matchers::MatcherGenericBase</a></code>. Your type has to also provide two methods, <code>bool match( ... ) const</code> and overridden <code>std::string describe() const</code>.</p>
<p>Unlike with old-style matchers, there are no requirements on how the <code>match</code> member function takes its argument. This means that the argument can be taken by value or by mutating reference, but also that the matcher's <code>match</code> member function can be templated.</p>
<p>This allows you to write more complex matcher, such as a matcher that can compare one range-like (something that responds to <code>begin</code> and <code>end</code>) object to another, like in the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="catch__test__macros_8hpp.html">catch2/catch_test_macros.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="catch__matchers__templated_8hpp.html">catch2/matchers/catch_matchers_templated.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structEqualsRangeMatcher.html">EqualsRangeMatcher</a> : <a class="code" href="classCatch_1_1Matchers_1_1MatcherGenericBase.html">Catch::Matchers::MatcherGenericBase</a> {</div>
<div class="line">    <a class="code" href="structEqualsRangeMatcher.html#a5ca50ed6f77eaac97998a2c0ceaccd5a">EqualsRangeMatcher</a>(Range <span class="keyword">const</span>&amp; <a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>):</div>
<div class="line">        <a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>{ <a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a> }</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherRange&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="structEqualsRangeMatcher.html#a4de6c6d136b33309e0df53c34e4015eb">match</a>(OtherRange <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keyword">using</span> std::begin; <span class="keyword">using</span> std::end;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::equal(begin(<a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>), end(<a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>), begin(other), end(other));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code" href="structEqualsRangeMatcher.html#a379def2a168f84bdf28d83abb42a5b26">describe</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Equals: &quot;</span> + <a class="code" href="namespaceCatch.html#af13494e925a793e3e7143c6ce6f442c2">Catch::rangeToString</a>(<a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Range <span class="keyword">const</span>&amp; <a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="Matchers_8tests_8cpp.html#a82b834a8ba9f891c0f182734e9140b1f">EqualsRange</a>(<span class="keyword">const</span> Range&amp; <a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>) -&gt; <a class="code" href="structEqualsRangeMatcher.html">EqualsRangeMatcher&lt;Range&gt;</a> {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structEqualsRangeMatcher.html">EqualsRangeMatcher&lt;Range&gt;</a>{<a class="code" href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">range</a>};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="catch__amalgamated_8hpp.html#abd6e2aec703006b3da62cf7860c9808f">TEST_CASE</a>(<span class="stringliteral">&quot;Combining templated matchers&quot;</span>, <span class="stringliteral">&quot;[matchers][templated]&quot;</span>) {</div>
<div class="line">    std::array&lt;int, 3&gt; container{{ 1,2,3 }};</div>
<div class="line"> </div>
<div class="line">    std::array&lt;int, 3&gt; a{{ 1,2,3 }};</div>
<div class="line">    std::vector&lt;int&gt; b{ 0,1,2 };</div>
<div class="line">    std::list&lt;int&gt; c{ 4,5,6 };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="catch__matchers_8hpp.html#ac1354db6f3e9c1e0a8eda0eea7ff1f0a">REQUIRE_THAT</a>(container, <a class="code" href="Matchers_8tests_8cpp.html#a82b834a8ba9f891c0f182734e9140b1f">EqualsRange</a>(a) || <a class="code" href="Matchers_8tests_8cpp.html#a82b834a8ba9f891c0f182734e9140b1f">EqualsRange</a>(b) || <a class="code" href="Matchers_8tests_8cpp.html#a82b834a8ba9f891c0f182734e9140b1f">EqualsRange</a>(c));</div>
<div class="line">}</div>
<div class="ttc" id="aMatchers_8tests_8cpp_html_a82b834a8ba9f891c0f182734e9140b1f"><div class="ttname"><a href="Matchers_8tests_8cpp.html#a82b834a8ba9f891c0f182734e9140b1f">EqualsRange</a></div><div class="ttdeci">auto EqualsRange(const Range &amp;range) -&gt; EqualsRangeMatcher&lt; Range &gt;</div><div class="ttdef"><b>Definition:</b> Matchers.tests.cpp:817</div></div>
<div class="ttc" id="acatch__amalgamated_8hpp_html_abd6e2aec703006b3da62cf7860c9808f"><div class="ttname"><a href="catch__amalgamated_8hpp.html#abd6e2aec703006b3da62cf7860c9808f">TEST_CASE</a></div><div class="ttdeci">#define TEST_CASE(...)</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.hpp:6257</div></div>
<div class="ttc" id="acatch__matchers__templated_8hpp_html"><div class="ttname"><a href="catch__matchers__templated_8hpp.html">catch_matchers_templated.hpp</a></div></div>
<div class="ttc" id="acatch__test__macros_8hpp_html"><div class="ttname"><a href="catch__test__macros_8hpp.html">catch_test_macros.hpp</a></div></div>
<div class="ttc" id="aclassCatch_1_1Matchers_1_1MatcherGenericBase_html"><div class="ttname"><a href="classCatch_1_1Matchers_1_1MatcherGenericBase.html">Catch::Matchers::MatcherGenericBase</a></div><div class="ttdef"><b>Definition:</b> catch_matchers_templated.hpp:23</div></div>
<div class="ttc" id="anamespaceCatch_1_1Generators_html_a3c79134931f824e63588bfa5baa77a43"><div class="ttname"><a href="namespaceCatch_1_1Generators.html#a3c79134931f824e63588bfa5baa77a43">Catch::Generators::range</a></div><div class="ttdeci">GeneratorWrapper&lt; T &gt; range(T const &amp;start, T const &amp;end, T const &amp;step)</div><div class="ttdef"><b>Definition:</b> catch_generators_range.hpp:54</div></div>
<div class="ttc" id="anamespaceCatch_html_af13494e925a793e3e7143c6ce6f442c2"><div class="ttname"><a href="namespaceCatch.html#af13494e925a793e3e7143c6ce6f442c2">Catch::rangeToString</a></div><div class="ttdeci">std::string rangeToString(Range const &amp;range)</div><div class="ttdef"><b>Definition:</b> catch_amalgamated.hpp:2924</div></div>
<div class="ttc" id="astructEqualsRangeMatcher_html"><div class="ttname"><a href="structEqualsRangeMatcher.html">EqualsRangeMatcher</a></div><div class="ttdef"><b>Definition:</b> Matchers.tests.cpp:796</div></div>
<div class="ttc" id="astructEqualsRangeMatcher_html_a379def2a168f84bdf28d83abb42a5b26"><div class="ttname"><a href="structEqualsRangeMatcher.html#a379def2a168f84bdf28d83abb42a5b26">EqualsRangeMatcher::describe</a></div><div class="ttdeci">std::string describe() const override</div><div class="ttdef"><b>Definition:</b> Matchers.tests.cpp:808</div></div>
<div class="ttc" id="astructEqualsRangeMatcher_html_a4de6c6d136b33309e0df53c34e4015eb"><div class="ttname"><a href="structEqualsRangeMatcher.html#a4de6c6d136b33309e0df53c34e4015eb">EqualsRangeMatcher::match</a></div><div class="ttdeci">bool match(OtherRange const &amp;other) const</div><div class="ttdef"><b>Definition:</b> Matchers.tests.cpp:800</div></div>
<div class="ttc" id="astructEqualsRangeMatcher_html_a5ca50ed6f77eaac97998a2c0ceaccd5a"><div class="ttname"><a href="structEqualsRangeMatcher.html#a5ca50ed6f77eaac97998a2c0ceaccd5a">EqualsRangeMatcher::EqualsRangeMatcher</a></div><div class="ttdeci">EqualsRangeMatcher(Range const &amp;range)</div><div class="ttdef"><b>Definition:</b> Matchers.tests.cpp:798</div></div>
</div><!-- fragment --><p>Do note that while you can rewrite any matcher from the old style to a new style matcher, combining new style matchers is more expensive in terms of compilation time. Also note that you can combine old style and new style matchers arbitrarily.</p>
<blockquote class="doxtable">
<p><code>MatcherGenericBase</code> lives in <code><a class="el" href="catch__matchers__templated_8hpp.html">catch2/matchers/catch_matchers_templated.hpp</a></code> </p>
</blockquote>
<hr  />
<p><a href="Readme.md#top">Home</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
